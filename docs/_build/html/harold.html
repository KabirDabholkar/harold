

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>harold package &mdash; harold 0.1.1a5 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="harold 0.1.1a5 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> harold
          

          
          </a>

          
            
            
              <div class="version">
                0.1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="preflight.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="primer.html">A primer to harold</a></li>
<li class="toctree-l1"><a class="reference internal" href="tut_models.html">Model Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="tut_convert.html">Conversion of Dynamic Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="tut_discrete.html">Discretization Methods</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">ChangeLog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">harold</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>harold package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/harold.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="harold-package">
<h1>harold package<a class="headerlink" href="#harold-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-harold.harold">
<span id="harold-harold-module"></span><h2>harold.harold module<a class="headerlink" href="#module-harold.harold" title="Permalink to this headline">¶</a></h2>
<p>The MIT License (MIT)</p>
<p>Copyright (c) 2015 Ilhan Polat</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &#8220;Software&#8221;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &#8220;AS IS&#8221;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p>
<dl class="class">
<dt id="harold.harold.Transfer">
<em class="property">class </em><code class="descclassname">harold.harold.</code><code class="descname">Transfer</code><span class="sig-paren">(</span><em>num</em>, <em>den=None</em>, <em>dt=False</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.Transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Transfer is the one of two main system classes in harold (together
with State()).</p>
<p>Main types of instantiation of this class depends on whether the
user wants to create a Single Input/Single Output system (SISO) or
a Multiple Input/Multiple Output system (MIMO) model.</p>
<p>For SISO system creation, 1D lists or 1D numpy arrays are expected,
e.g.,:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; G = Transfer(1,[1,2,1])</span>
</pre></div>
</div>
<p>For MIMO systems, depending on the shared denominators, there are
two distinct ways of entering a MIMO transfer function:</p>
<blockquote>
<div><p>1.  Entering &#8220;list of lists of lists&#8221; such that every element of the
inner lists are numpy array-able (explicitly checked) for numerator
and entering a 1D list or 1D numpy array for denominator (and
similarly for numerator):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; G = Transfer([[[1,3,2],[1,3]],[[1],[1,0]]],[1,4,5,2])</span>
<span class="go">&gt;&gt;&gt;&gt; G.shape</span>
<span class="go">(2,2)</span>
</pre></div>
</div>
<p>2. Entering the denominator also as a list of lists for individual
entries as a bracket nightmare (thanks to Python&#8217;s nonnative support
for arrays and tedious array syntax):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span> <span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">G</span> <span class="o">=</span> <span class="n">Transfer</span><span class="p">([</span>
          <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">],</span>
          <span class="p">[</span>   <span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>
        <span class="p">],</span><span class="c1"># end of num</span>
        <span class="p">[</span>
           <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>  <span class="p">],</span>
           <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">]</span>
        <span class="p">])</span>
<span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>There is a very involved validator and if you would like to know
why or how this input is handled ,provide the same numerator and
denominator to the static method below with &#8216;verbose=True&#8217; keyword
argument, e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; n , d , shape , is_it_static = Transfer.validate_arguments(</span>
<span class="go">          [1,3,2], # common numerator</span>
<span class="go">          [[[1,2,1],[1,3,3]],[[1,0,0],[1,2,3,4]]],# explicit den</span>
<span class="go">          verbose=True # print the logic it followed</span>
<span class="go">          )</span>
</pre></div>
</div>
<p>would give information about the context together with the
regularized numerator, denominator, resulting system shape
and boolean whether or not the system has dynamics.</p>
<p>However, the preferred way is to make everything a numpy array inside
the list of lists. That would skip many compatibility checks.
Once created the shape of the numerator and denominator cannot be
changed. But compatible sized arrays can be supplied and it will
recalculate the pole/zero locations etc. properties automatically.</p>
<p>The Sampling Period can be given as a last argument or a keyword
with &#8216;dt&#8217; key or changed later with the property access.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; G = Transfer([1],[1,4,4],0.5)</span>
<span class="go">&gt;&gt;&gt;&gt; G.SamplingSet</span>
<span class="go">&#39;Z&#39;</span>
<span class="go">&gt;&gt;&gt;&gt; G.SamplingPeriod</span>
<span class="go">0.5</span>
<span class="go">&gt;&gt;&gt;&gt; F = Transfer([1],[1,2])</span>
<span class="go">&gt;&gt;&gt;&gt; F.SamplingSet</span>
<span class="go">&#39;R&#39;</span>
<span class="go">&gt;&gt;&gt;&gt; F.SamplingPeriod = 0.5</span>
<span class="go">&gt;&gt;&gt;&gt; F.SamplingSet</span>
<span class="go">&#39;Z&#39;</span>
<span class="go">&gt;&gt;&gt;&gt; F.SamplingPeriod</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>Providing &#8216;False&#8217; value to the SamplingPeriod property will make
the system continous time again and relevant properties are reset
to CT properties.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Unlike matlab or other tools, a discrete time system
needs a specified sampling period (and possibly a discretization
method if applicable) because a model without a sampling period
doesn&#8217;t make sense for analysis. If you don&#8217;t care, then make up
a number, say, a million, since you don&#8217;t care.</p>
</div>
<dl class="attribute">
<dt id="harold.harold.Transfer.SamplingSet">
<code class="descname">SamplingSet</code><a class="headerlink" href="#harold.harold.Transfer.SamplingSet" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.SamplingSet</span></code> then returns the
set <code class="docutils literal"><span class="pre">Z</span></code> or <code class="docutils literal"><span class="pre">R</span></code> for discrete and continous models respectively.
This is a read only property and cannot be set. Instead an appropriate
setting should be given to the <code class="docutils literal"><span class="pre">SamplingPeriod</span></code> property.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.NumberOfInputs">
<code class="descname">NumberOfInputs</code><a class="headerlink" href="#harold.harold.Transfer.NumberOfInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that holds the number of inputs.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.NumberOfOutputs">
<code class="descname">NumberOfOutputs</code><a class="headerlink" href="#harold.harold.Transfer.NumberOfOutputs" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that holds the number of outputs.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.shape">
<code class="descname">shape</code><a class="headerlink" href="#harold.harold.Transfer.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that holds the shape of the system as a tuple
such that the result is <code class="docutils literal"><span class="pre">(#</span> <span class="pre">of</span> <span class="pre">inputs</span> <span class="pre">,</span> <span class="pre">#</span> <span class="pre">of</span> <span class="pre">outputs)</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.polynomials">
<code class="descname">polynomials</code><a class="headerlink" href="#harold.harold.Transfer.polynomials" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that returns the model numerator and the
denominator as the outputs.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.SamplingPeriod">
<code class="descname">SamplingPeriod</code><a class="headerlink" href="#harold.harold.Transfer.SamplingPeriod" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.SamplingPeriod</span></code> then returns the
sampling period data. If this property is set to <code class="docutils literal"><span class="pre">False</span></code>, the model
is assumed to be a continuous model. Otherwise, a discrete time model
is assumed. Upon changing this value, relevant system properties are
recalculated.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.num">
<code class="descname">num</code><a class="headerlink" href="#harold.harold.Transfer.num" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.num</span></code> then returns the numerator data.
Alternatively, if this property is set then the provided value is
first validated with the existing denominator shape and causality.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.den">
<code class="descname">den</code><a class="headerlink" href="#harold.harold.Transfer.den" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.den</span></code> then returns the numerator data.
Alternatively, if this property is set then the provided value is
first validated with the existing numerator shape and causality.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.DiscretizedWith">
<code class="descname">DiscretizedWith</code><a class="headerlink" href="#harold.harold.Transfer.DiscretizedWith" title="Permalink to this definition">¶</a></dt>
<dd><p>This property is used internally to keep track of (if applicable)
the original method used for discretization. It is used by the
<code class="docutils literal"><span class="pre">undiscretize()</span></code> function to reach back to the continous model that
would hopefully minimize the discretization errors. It is also
possible to manually set this property such that <code class="docutils literal"><span class="pre">undiscretize</span></code>
uses the provided method.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.DiscretizationMatrix">
<code class="descname">DiscretizationMatrix</code><a class="headerlink" href="#harold.harold.Transfer.DiscretizationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This matrix denoted with <span class="math">\(Q\)</span> is internally used to represent
the upper linear fractional transformation of the operation
<span class="math">\(\frac{1}{s} I = \frac{1}{z} I \star Q\)</span>. For example, the
typical tustin, forward/backward difference methods can be represented
with</p>
<div class="math">
\[\begin{split}Q = \begin{bmatrix} I &amp; \sqrt{T}I \\ \sqrt{T}I &amp; \alpha TI
\end{bmatrix}\end{split}\]</div>
<p>then for different <span class="math">\(\alpha\)</span> values corresponds to the
transformation given below:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math">\(\alpha\)</span></th>
<th class="head">method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(0\)</span></td>
<td>backward difference (euler)</td>
</tr>
<tr class="row-odd"><td><span class="math">\(0.5\)</span></td>
<td>tustin</td>
</tr>
<tr class="row-even"><td><span class="math">\(1\)</span></td>
<td>forward difference (euler)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>This operation is usually given with a Riemann sum argument however
for control theoretical purposes a proper mapping argument immediately
suggests a more precise control over the domain the left half plane is
mapped to. For this reason, a discretization matrix option is provided
to the user.</p>
<p>The available methods (and their aliases) can be accessed via the
internal <code class="docutils literal"><span class="pre">_KnownDiscretizationMethods</span></code> variable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The common discretization techniques can be selected with
a keyword argument and this matrix business can safely be
avoided. This is a rather technical issue and it is best to
be used sparingly. For the experts, I have to note that
the transformation is currently not tested for well-posedness.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">SciPy actually uses a variant of this LFT
representation as given in the paper of <a class="reference external" href="http://dx.doi.org/10.1080/00207170802247728">Zhang et al.</a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.Transfer.PrewarpFrequency">
<code class="descname">PrewarpFrequency</code><a class="headerlink" href="#harold.harold.Transfer.PrewarpFrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>If the discretization method is <code class="docutils literal"><span class="pre">tustin</span></code> then a frequency warping
correction might be required the match of the discrete time system
response at the frequency band of interest. Via this property, the
prewarp frequency can be provided.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="harold.harold.Transfer.validate_arguments">
<em class="property">static </em><code class="descname">validate_arguments</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.Transfer.validate_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper function to validate whether given arguments to an
Transfer instance are valid and compatible for instantiation.</p>
<p>Since there are many cases that might lead to a valid Transfer
instance, Pythonic &#8220;try,except&#8221; machinery is not very helpful
to check every possibility and equally challenging to branch
off. A few examples of such issues that needs to be addressed
is static gain, single entry for a MIMO system with common
denominators and so on.</p>
<p>Thus, this function provides a front-end to the laborious size
and type checking which would make the Transfer object itself
seemingly compatible with duck-typing while keeping the nasty
branching implementation internal.</p>
<p>The resulting output is compatible with the main harold
Transfer class convention such that</p>
<blockquote>
<div><ul class="simple">
<li>If the recognized context is MIMO the resulting outputs are
list of lists with numpy arrays being the polynomial
coefficient entries.</li>
<li>If the recognized context is SISO the entries are numpy
arrays with any list structure is stripped off.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num</strong> &#8211; <p>The polynomial coefficient containers. Either of them
can be (not both) None to assume that the context will
be derived from the other for static gains. Otherwise
both are expected to be one of np.array, int , float , list ,
list of lists of lists or numpy arrays.</p>
<p>For MIMO context, element numbers and causality
checks are performed such that numerator list of
list has internal arrays that have less than or
equal to the internal arrays of the respective
denominator entries.</p>
<p>For SISO context, causality check is performed
between numerator and denominator arrays.</p>
</li>
<li><strong>den</strong> &#8211; Same as num</li>
<li><strong>verbose</strong> (<em>boolean</em>) &#8211; A boolean switch to print out what this method thinksabout the
argument context.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>num</strong> (<em>List of lists or numpy array (MIMO/SISO)</em>)</li>
<li><strong>den</strong> (<em>List of lists or numpy array (MIMO/SISO)</em>)</li>
<li><strong>shape</strong> (<em>2-tuple</em>) &#8211; Returns the recognized shape of the system</li>
<li><strong>Gain_flag</strong> (<em>Boolean</em>) &#8211; Returns <code class="docutils literal"><span class="pre">True</span></code> if the system is recognized as a static gain
<code class="docutils literal"><span class="pre">False</span></code> otherwise (for both SISO and MIMO)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="harold.harold.State">
<em class="property">class </em><code class="descclassname">harold.harold.</code><code class="descname">State</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em>, <em>c=None</em>, <em>d=None</em>, <em>dt=False</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.State" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>State() is the one of two main system classes in harold (together with
Transfer() ).</p>
<p>A State object can be instantiated in a straightforward manner by
entering 2D arrays, floats, 1D arrays for row vectors and so on.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; G = State([[0,1],[-4,-5]],[[0],[1]],[[1,0]],1)</span>
</pre></div>
</div>
<p>However, the preferred way is to make everything a numpy array.
That would skip many compatibility checks. Once created the shape
of the system matrices cannot be changed. But compatible
sized arrays can be supplied and it will recalculate the pole/zero
locations etc. properties automatically.</p>
<p>The Sampling Period can be given as a last argument or a keyword
with &#8216;dt&#8217; key or changed later with the property access.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; G = State([[0,1],[-4,-5]],[[0],[1]],[[1,0]],[1],0.5)</span>
<span class="go">&gt;&gt;&gt;&gt; G.SamplingSet</span>
<span class="go">&#39;Z&#39;</span>
<span class="go">&gt;&gt;&gt;&gt; G.SamplingPeriod</span>
<span class="go">0.5</span>
<span class="go">&gt;&gt;&gt;&gt; F = State(1,2,3,4)</span>
<span class="go">&gt;&gt;&gt;&gt; F.SamplingSet</span>
<span class="go">&#39;R&#39;</span>
<span class="go">&gt;&gt;&gt;&gt; F.SamplingPeriod = 0.5</span>
<span class="go">&gt;&gt;&gt;&gt; F.SamplingSet</span>
<span class="go">&#39;Z&#39;</span>
<span class="go">&gt;&gt;&gt;&gt; F.SamplingPeriod</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>Setting  SamplingPeriod property to &#8216;False&#8217; value to the will make
the system continous time again and relevant properties are reset
to continuous-time properties.</p>
<p>Warning: Unlike matlab or other tools, a discrete time system
needs a specified sampling period (and possibly a discretization
method if applicable) because a model without a sampling period
doesn&#8217;t make sense for analysis. If you don&#8217;t care, then make up
a number, say, a million, since you don&#8217;t care.</p>
<dl class="attribute">
<dt id="harold.harold.State.SamplingSet">
<code class="descname">SamplingSet</code><a class="headerlink" href="#harold.harold.State.SamplingSet" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.SamplingSet</span></code> then returns the
set <code class="docutils literal"><span class="pre">Z</span></code> or <code class="docutils literal"><span class="pre">R</span></code> for discrete and continous models respectively.
This is a read only property and cannot be set. Instead an appropriate
setting should be given to the <code class="docutils literal"><span class="pre">SamplingPeriod</span></code> property.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.NumberOfStates">
<code class="descname">NumberOfStates</code><a class="headerlink" href="#harold.harold.State.NumberOfStates" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that holds the number of states.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.NumberOfInputs">
<code class="descname">NumberOfInputs</code><a class="headerlink" href="#harold.harold.State.NumberOfInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that holds the number of inputs.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.NumberOfOutputs">
<code class="descname">NumberOfOutputs</code><a class="headerlink" href="#harold.harold.State.NumberOfOutputs" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that holds the number of outputs.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.shape">
<code class="descname">shape</code><a class="headerlink" href="#harold.harold.State.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that holds the shape of the system as a tuple
such that the result is <code class="docutils literal"><span class="pre">(#</span> <span class="pre">of</span> <span class="pre">inputs</span> <span class="pre">,</span> <span class="pre">#</span> <span class="pre">of</span> <span class="pre">outputs)</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.matrices">
<code class="descname">matrices</code><a class="headerlink" href="#harold.harold.State.matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>A read only property that returns the model matrices.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.a">
<code class="descname">a</code><a class="headerlink" href="#harold.harold.State.a" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.a</span></code> then returns the matrix data.
Alternatively, if this property is set then the provided value is
first validated with the existing system shape and number of states.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.b">
<code class="descname">b</code><a class="headerlink" href="#harold.harold.State.b" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.b</span></code> then returns the matrix data.
Alternatively, if this property is set then the provided value is
first validated with the existing system shape and number of states.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.c">
<code class="descname">c</code><a class="headerlink" href="#harold.harold.State.c" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.c</span></code> then returns the matrix data.
Alternatively, if this property is set then the provided value is
first validated with the existing system shape and number of states.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.d">
<code class="descname">d</code><a class="headerlink" href="#harold.harold.State.d" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.a</span></code> then returns the matrix data.
Alternatively, if this property is set then the provided value is
first validated with the existing system shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.SamplingPeriod">
<code class="descname">SamplingPeriod</code><a class="headerlink" href="#harold.harold.State.SamplingPeriod" title="Permalink to this definition">¶</a></dt>
<dd><p>If this property is called <code class="docutils literal"><span class="pre">G.SamplingPeriod</span></code> then returns the
sampling period data. If this property is set to <code class="docutils literal"><span class="pre">False</span></code>, the model
is assumed to be a continuous model. Otherwise, a discrete time model
is assumed. Upon changing this value, relevant system properties are
recalculated.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.DiscretizedWith">
<code class="descname">DiscretizedWith</code><a class="headerlink" href="#harold.harold.State.DiscretizedWith" title="Permalink to this definition">¶</a></dt>
<dd><p>This property is used internally to keep track of (if applicable)
the original method used for discretization. It is used by the
<code class="docutils literal"><span class="pre">undiscretize()</span></code> function to reach back to the continous model that
would hopefully minimize the discretization errors. It is also
possible to manually set this property such that <code class="docutils literal"><span class="pre">undiscretize</span></code>
uses the provided method.</p>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.DiscretizationMatrix">
<code class="descname">DiscretizationMatrix</code><a class="headerlink" href="#harold.harold.State.DiscretizationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This matrix denoted with <span class="math">\(Q\)</span> is internally used to represent
the upper linear fractional transformation of the operation
<span class="math">\(\frac{1}{s} I = \frac{1}{z} I \star Q\)</span>. For example, the
typical tustin, forward/backward difference methods can be represented
with</p>
<div class="math">
\[\begin{split}Q = \begin{bmatrix} I &amp; \sqrt{T}I \\ \sqrt{T}I &amp; \alpha TI
\end{bmatrix}\end{split}\]</div>
<p>then for different <span class="math">\(\alpha\)</span> values corresponds to the
transformation given below:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math">\(\alpha\)</span></th>
<th class="head">method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(0\)</span></td>
<td>backward difference (euler)</td>
</tr>
<tr class="row-odd"><td><span class="math">\(0.5\)</span></td>
<td>tustin</td>
</tr>
<tr class="row-even"><td><span class="math">\(1\)</span></td>
<td>forward difference (euler)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>This operation is usually given with a Riemann sum argument however
for control theoretical purposes a proper mapping argument immediately
suggests a more precise control over the domain the left half plane is
mapped to. For this reason, a discretization matrix option is provided
to the user.</p>
<p>The available methods (and their aliases) can be accessed via the
internal <code class="docutils literal"><span class="pre">_KnownDiscretizationMethods</span></code> variable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The common discretization techniques can be selected with
a keyword argument and this matrix business can safely be
avoided. This is a rather technical issue and it is best to
be used sparingly. For the experts, I have to note that
the transformation is currently not tested for well-posedness.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">SciPy actually uses a variant of this LFT
representation as given in the paper of <a class="reference external" href="http://dx.doi.org/10.1080/00207170802247728">Zhang et al.</a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="harold.harold.State.PrewarpFrequency">
<code class="descname">PrewarpFrequency</code><a class="headerlink" href="#harold.harold.State.PrewarpFrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>If the discretization method is <code class="docutils literal"><span class="pre">tustin</span></code> then a frequency warping
correction might be required the match of the discrete time system
response at the frequency band of interest. Via this property, the
prewarp frequency can be provided.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="harold.harold.State.validate_arguments">
<em class="property">static </em><code class="descname">validate_arguments</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.State.validate_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>An internal command to validate whether given arguments to a
State() instance are valid and compatible.</p>
<p>It also checks if the lists are 2D numpy.array&#8217;able entries.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="harold.harold.statetotransfer">
<code class="descclassname">harold.harold.</code><code class="descname">statetotransfer</code><span class="sig-paren">(</span><em>*state_or_abcd</em>, <em>*</em>, <em>output='system'</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.statetotransfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a State() object of a tuple of A,B,C,D array-likes, converts
the argument into the transfer representation. The output can be
selected as a Transfer() object or the numerator, denominator if
&#8216;output&#8217; keyword is given with the option &#8216;polynomials&#8217;.</p>
<p>If the input is a Transfer() object it returns the argument with no
modifications.</p>
<p>The algorithm is to first get the minimal realization of the State()
representation. Then implements the conversion ala Varga,Sima 1981
which can be summarized as iterating over every row/cols of B and C
to get SISO Transfer representations via c*(sI-A)^(-1)*b+d</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state_or_abcd</strong> (<em>State() or a tuple of A,B,C,D matrices.</em>) &#8211; </li>
<li><strong>output</strong> (<em>{'system','polynomials'}</em>) &#8211; Selects whether a State() object or individual numerator, denominator
will be returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>G</strong> (<em>Transfer()</em>) &#8211; If &#8216;output&#8217; keyword is set to &#8216;system&#8217;</li>
<li><strong>num</strong> (<em>{List of lists of 2D-numpy arrays for MIMO case,</em>) &#8211;       2D-Numpy arrays for SISO case}
If the &#8216;output&#8217; keyword is set to &#8216;polynomials&#8217;</li>
<li><strong>den</strong> (<em>Same as num</em>)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.transfertostate">
<code class="descclassname">harold.harold.</code><code class="descname">transfertostate</code><span class="sig-paren">(</span><em>*tf_or_numden</em>, <em>*</em>, <em>output='system'</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.transfertostate" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a Transfer() object of a tuple of numerator and denominator,
converts the argument into the state representation. The output can
be selected as a State() object or the A,B,C,D matrices if &#8216;output&#8217;
keyword is given with the option &#8216;matrices&#8217;.</p>
<p>If the input is a State() object it returns the argument with no
modifications.</p>
<p>For SISO systems, the algorithm is returning the controllable
companion form.</p>
<p>For MIMO systems a variant of the algorithm given in Section 4.4 of
W.A. Wolowich, Linear Multivariable Systems (1974). The denominators
are equaled with haroldlcm() Least Common Multiple function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tf_or_numden</strong> (<em>Transfer() or a tuple of numerator and denominator.</em>) &#8211; For MIMO numerator and denominator arguments see Transfer()
docstring.</li>
<li><strong>output</strong> (<em>{'system','matrices'}</em>) &#8211; Selects whether a State() object or individual state matrices
will be returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>G</strong> (<em>State()</em>) &#8211; If &#8216;output&#8217; keyword is set to &#8216;system&#8217;</li>
<li><strong>A,B,C,D</strong> (<em>{(nxn),(nxm),(p,n),(p,m)} 2D Numpy-arrays</em>) &#8211; If the &#8216;output&#8217; keyword is set to &#8216;matrices&#8217;</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.transmission_zeros">
<code class="descclassname">harold.harold.</code><code class="descname">transmission_zeros</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>C</em>, <em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.transmission_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the transmission zeros of a (A,B,C,D) system matrix quartet.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a straightforward implementation of the algorithm of Misra,
van Dooren, Varga 1994 but skipping the descriptor matrix which in
turn becomes Emami-Naeini,van Dooren 1979. I don&#8217;t know if anyone
actually uses descriptor systems in practice so I removed the
descriptor parts to reduce the clutter. Hence, it is possible to
directly row/column compress the matrices without caring about the
upper Hessenbergness of E matrix.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>A,B,C,D</strong> (<em>{(nxn),(nxm),(p,n),(p,m) 2D Numpy arrays}</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>z</strong> &#8211; The array of computed transmission zeros. The array is returned
empty if no transmission zeros are found.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">{1D Numpy array}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.discretize">
<code class="descclassname">harold.harold.</code><code class="descname">discretize</code><span class="sig-paren">(</span><em>G</em>, <em>dt</em>, <em>method='tustin'</em>, <em>PrewarpAt=0.0</em>, <em>q=None</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.discretize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="harold.harold.undiscretize">
<code class="descclassname">harold.harold.</code><code class="descname">undiscretize</code><span class="sig-paren">(</span><em>G</em>, <em>OverrideWith=None</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.undiscretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a discrete time system model continuous system model.
If the model has the Discretization Method set, then uses that
discretization method to reach back to the continous system model.</p>
</dd></dl>

<dl class="function">
<dt id="harold.harold.rediscretize">
<code class="descclassname">harold.harold.</code><code class="descname">rediscretize</code><span class="sig-paren">(</span><em>G</em>, <em>dt</em>, <em>method='tustin'</em>, <em>alpha=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.rediscretize" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Not implemented yet!</p>
</div>
</dd></dl>

<dl class="function">
<dt id="harold.harold.kalman_controllability">
<code class="descclassname">harold.harold.</code><code class="descname">kalman_controllability</code><span class="sig-paren">(</span><em>G</em>, <em>compress=False</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.kalman_controllability" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Kalman controllability related quantities. The algorithm
is the literal computation of the controllability matrix with increasing
powers of A. Numerically, this test is not robust and prone to errors if
the A matrix is not well-conditioned or its entries have varying order
of magnitude as at each additional power of A the entries blow up or
converge to zero rapidly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> (<em>State() or tuple of {(n,n),(n,m)} array_like matrices</em>) &#8211; System or matrices to be tested</li>
<li><strong>compress</strong> (<em>Boolean</em>) &#8211; If set to True, then the returned controllability matrix is row
compressed, and in case of uncontrollable modes, has that many
zero rows.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>Cc</strong> (<em>{(n,nxm)} 2D numpy array</em>) &#8211; Kalman Controllability Matrix</li>
<li><strong>T</strong> (<em>(n,n) 2D numpy arrays</em>) &#8211; The transformation matrix such that T^T * Cc is row compressed
and the number of zero rows at the bottom corresponds to the number
of uncontrollable modes.</li>
<li><strong>r</strong> (<em>integer</em>) &#8211; Numerical rank of the controllability matrix</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.kalman_observability">
<code class="descclassname">harold.harold.</code><code class="descname">kalman_observability</code><span class="sig-paren">(</span><em>G</em>, <em>compress=False</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.kalman_observability" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Kalman observability related objects. The algorithm
is the literal computation of the observability matrix with increasing
powers of A. Numerically, this test is not robust and prone to errors if
the A matrix is not well-conditioned or too big as at each additional
power of A the entries blow up or converge to zero rapidly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> (<em>State() or {(n,n),(n,m)} array_like matrices</em>) &#8211; System or matrices to be tested</li>
<li><strong>compress</strong> (<em>Boolean</em>) &#8211; If set to True, then the returned observability matrix is row
compressed, and in case of unobservability modes, has that many
zero rows.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>Co</strong> (<em>{(n,nxm)} 2D numpy array</em>) &#8211; Kalman observability matrix</li>
<li><strong>T</strong> (<em>(n,n) 2D numpy arrays</em>) &#8211; The transformation matrix such that T^T * Cc is row compressed
and the number of zero rows on the right corresponds to the number
of unobservable modes.</li>
<li><strong>r</strong> (<em>integer</em>) &#8211; Numerical rank of the observability matrix</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.kalman_decomposition">
<code class="descclassname">harold.harold.</code><code class="descname">kalman_decomposition</code><span class="sig-paren">(</span><em>G</em>, <em>compute_T=False</em>, <em>output='system'</em>, <em>cleanup_threshold=1e-09</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.kalman_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>By performing a sequence of similarity transformations the State
representation is transformed into a special structure such that
if the system has uncontrollable/unobservable modes, the corresponding
rows/columns of the B/C matrices have zero blocks and the modes
are isolated in the A matrix. That is to say, there is no contribution
of the controllable/observable states on the dynamics of these modes.</p>
<p>Note that, Kalman operations are numerically not robust. Hence the
resulting decomposition might miss some &#8216;almost&#8217; pole-zero cancellations.
Hence, this should be used as a rough assesment tool but not as
actual minimality check or maybe to demonstrate the concepts academic
purposes to show the modal decomposition. Use canceldistance() and
minimal_realization() functions instead with better numerical properties.</p>
<p>Example usage and verification :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>G = State([[2,1,1],[5,3,6],[-5,-1,-4]],[[1],[0],[0]],[[1,0,0]],0)
print(&#39;Is it Kalman Cont&#39;ble ? &#39;,is_kalman_controllable(G))
print(&#39;Is it Kalman Obsv&#39;ble ? &#39;,is_kalman_observable(G))
F = kalman_decomposition(G)
print(F.a,F.b,F.c)
H = minimal_realization(F.a,F.b,F.c)
print(&#39;The minimal system matrices are:&#39;,*H)
</pre></div>
</div>
<p>Expected output :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Is</span> <span class="n">it</span> <span class="n">Kalman</span> <span class="n">Cont</span><span class="s1">&#39;ble ?  False</span>
<span class="n">Is</span> <span class="n">it</span> <span class="n">Kalman</span> <span class="n">Obsv</span><span class="s1">&#39;ble ?  False</span>
<span class="p">[[</span> <span class="mf">2.</span>          <span class="mf">0.</span>         <span class="o">-</span><span class="mf">1.41421356</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">7.07106781</span> <span class="o">-</span><span class="mf">3.</span>         <span class="o">-</span><span class="mf">7.</span>        <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">2.</span>        <span class="p">]]</span>

<span class="p">[[</span><span class="o">-</span><span class="mf">1.</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span><span class="p">]]</span>

<span class="p">[[</span><span class="o">-</span><span class="mf">1.</span>  <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">The</span> <span class="n">minimal</span> <span class="n">system</span> <span class="n">matrices</span> <span class="n">are</span><span class="p">:</span>
 <span class="p">[[</span> <span class="mf">2.</span><span class="p">]]</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">]]</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Kalman decomposition is often described in an ambigous fashion
in the literature. I would like to thank Joaquin Carrasco for
his generous help on this matter for his lucid argument as to
why this is probably happening. This is going to be
reimplemented with better tests on pathological models.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> (<a class="reference internal" href="#harold.harold.State" title="harold.harold.State"><em>State()</em></a>) &#8211; The state representation that is to be converted into the block
triangular form such that unobservable/uncontrollable modes
corresponds to zero blocks in B/C matrices</li>
<li><strong>compute_T</strong> (<em>boolean</em>) &#8211; Selects whether the similarity transformation matrix will be
returned.</li>
<li><strong>output</strong> (<em>{'system','matrices'}</em>) &#8211; Selects whether a State() object or individual state matrices
will be returned.</li>
<li><strong>cleanup_threshold</strong> (<em>float</em>) &#8211; After the similarity transformation, the matrix entries smaller
than this threshold in absolute value would be zeroed. Setting
this value to zero turns this behavior off.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>Gk</strong> (<em>State() or if output = &#8216;matrices&#8217; is selected (A,B,C,D) tuple</em>) &#8211; Returns a state representation or its matrices as a tuple</p>
</li>
<li><p class="first"><strong>T</strong> (<em>(nxn) 2D-numpy array</em>) &#8211; If compute_T is True, returns the similarity transform matrix
that brings the state representation in the resulting decomposed
form such that</p>
<blockquote>
<div><p>Gk.a = inv(T)*G.a*T
Gk.b = inv(T)*G.b
Gk.c = G.c*T
Gk.d = G.d</p>
</div></blockquote>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.is_kalman_controllable">
<code class="descclassname">harold.harold.</code><code class="descname">is_kalman_controllable</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.is_kalman_controllable" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests the rank of the Kalman controllability matrix and compares it
with the A matrix size, returns a boolean depending on the outcome.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>G</strong> (<em>State() or tuple of {(nxn),(nxm)} array_like matrices</em>) &#8211; The system or the (A,B) matrix tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>test_bool</strong> &#8211; Returns True if the input is Kalman controllable</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.is_kalman_observable">
<code class="descclassname">harold.harold.</code><code class="descname">is_kalman_observable</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.is_kalman_observable" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests the rank of the Kalman observability matrix and compares it
with the A matrix size, returns a boolean depending on the outcome.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>G</strong> (<em>State() or tuple of {(nxn),(pxn)} array_like matrices</em>) &#8211; The system or the (A,C) matrix tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>test_bool</strong> &#8211; Returns True if the input is Kalman observable</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.staircase">
<code class="descclassname">harold.harold.</code><code class="descname">staircase</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>C</em>, <em>compute_T=False</em>, <em>form='c'</em>, <em>invert=False</em>, <em>block_indices=False</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.staircase" title="Permalink to this definition">¶</a></dt>
<dd><p>The staircase form is used very often to assess system properties.
Given a state system matrix triplet A,B,C, this function computes
the so-called controller/observer-Hessenberg form such that the resulting
system matrices have the block-form (x denoting the nonzero blocks)</p>
<div class="math">
\[\begin{split}\begin{array}{c|c}
    \begin{bmatrix}
        \times &amp; \times &amp; \times &amp; \times &amp; \times \\
        \times &amp; \times &amp; \times &amp; \times &amp; \times \\
        0       &amp; \times &amp; \times &amp; \times &amp; \times \\
        0       &amp; 0       &amp; \times &amp; \times &amp; \times \\
        0       &amp; 0       &amp;  0      &amp; \times &amp; \times
    \end{bmatrix} &amp;
    \begin{bmatrix}
        \times \\
        0       \\
        0       \\
        0       \\
        0
    \end{bmatrix} \\ \hline
    \begin{bmatrix}
        \times &amp; \times &amp; \times &amp; \times &amp; \times \\
        \times &amp; \times &amp; \times &amp; \times &amp; \times
    \end{bmatrix}
\end{array}\end{split}\]</div>
<p>For controllability and observability, the existence of zero-rank
subdiagonal blocks can be checked, as opposed to forming the Kalman
matrix and checking the rank. Staircase method can numerically be
more stable since for certain matrices, A^n computations can
introduce large errors (for some A that have entries with varying
order of magnitudes). But it is also prone to numerical rank guessing
mismatches.</p>
<p>Notice that, if we use the pertransposed data, then we have the
observer form which is usually asked from the user to supply
the data as <span class="math">\(A,B,C \Rightarrow A^T,C^T,B^T\)</span> and then transpose
back the result. This is just silly to ask the user to do that. Hence
the additional <code class="docutils literal"><span class="pre">form</span></code> option denoting whether it is the observer or
the controller form that is requested.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A,B,C</strong> (<em>{(n,n),(n,m),(p,n)} array_like</em>) &#8211; System Matrices to be converted</li>
<li><strong>compute_T</strong> (<em>bool, optional</em>) &#8211; Whether the transformation matrix T should be computed or not</li>
<li><strong>form</strong> (<em>{ 'c' , 'o' }, optional</em>) &#8211; Determines whether the controller- or observer-Hessenberg form
will be computed.</li>
<li><strong>invert</strong> (<em>bool, optional</em>) &#8211; Whether to select which side the B or C matrix will be compressed.
For example, the default case returns the B matrix with (if any)
zero rows at the bottom. invert option flips this choice either in
B or C matrices depending on the &#8220;form&#8221; switch.</li>
<li><strong>block_indices</strong> (<em>bool, optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>Ah,Bh,Ch</strong> (<em>{(n,n),(n,m),(p,n)} 2D numpy arrays</em>) &#8211; Converted system matrices</p>
</li>
<li><p class="first"><strong>T</strong> (<em>(n,n) 2D numpy array</em>) &#8211; If the boolean <code class="docutils literal"><span class="pre">compute_T</span></code> is true, returns the transformation
matrix such that</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c|c}
    T^{-1}AT &amp;T^{-1}B \\ \hline
    CT &amp; D
\end{array}\right]\end{split}\]</div>
<p>is in the desired staircase form.</p>
</li>
<li><p class="first"><strong>k</strong> (<em>Numpy array</em>) &#8211; If the boolean <code class="docutils literal"><span class="pre">block_indices</span></code> is true, returns the array
of controllable/observable block sizes identified during block
diagonalization</p>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.canceldistance">
<code class="descclassname">harold.harold.</code><code class="descname">canceldistance</code><span class="sig-paren">(</span><em>F</em>, <em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.canceldistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Given matrices <span class="math">\(F,G\)</span>, computes the upper and lower bounds of
the perturbation needed to render the pencil <span class="math">\(\left[
\begin{array}{c|c}F-pI &amp; G\end{array}\right]\)</span> rank deficient. It is
used for assessing the controllability/observability degenerate distance
and hence for minimality assessment.</p>
<p>Implements the algorithm given in D.Boley SIMAX vol.11(4) 1990.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>F,G</strong> (<em>2D arrays</em>) &#8211; Pencil matrices to be checked for rank deficiency distance</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>upper2</strong> (<em>float</em>) &#8211; Upper bound on the norm of the perturbation
<span class="math">\(\left[\begin{array}{c|c}dF &amp; dG\end{array}\right]\)</span> such
that <span class="math">\(\left[\begin{array}{c|c}F+dF-pI &amp; G+dG \end{array}
\right]\)</span> is rank deficient.</li>
<li><strong>upper1</strong> (<em>float</em>) &#8211; A theoretically softer upper bound than the upper2 for the
same quantity.</li>
<li><strong>lower0</strong> (<em>float</em>) &#8211; Lower bound on the same quantity given in upper2</li>
<li><strong>e_f</strong> (<em>complex</em>) &#8211; Indicates the eigenvalue that renders [F + dF - pI | G + dG ]
rank deficient i.e. equals to the p value at the closest rank
deficiency.</li>
<li><strong>radius</strong> (<em>float</em>) &#8211; The perturbation with the norm bound &#8220;upper2&#8221; is located within
a disk in the complex plane whose center is on &#8220;e_f&#8221; and whose
radius is bounded by this output.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.minimal_realization">
<code class="descclassname">harold.harold.</code><code class="descname">minimal_realization</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>C</em>, <em>mu_tol=1e-09</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.minimal_realization" title="Permalink to this definition">¶</a></dt>
<dd><p>Given state matrices <span class="math">\(A,B,C\)</span> computes minimal state matrices
such that the system is controllable and observable within the
given tolerance <span class="math">\(\mu\)</span>.</p>
<dl class="docutils">
<dt>Implements a basic two pass algorithm :</dt>
<dd>1- First distance to mode cancellation is computed then also
the Hessenberg form is obtained with the identified o&#8217;ble/c&#8217;ble
block numbers. If staircase form reports that there are no
cancellations but the distance is less than the tolerance,
distance wins and the respective mode is removed.</dd>
</dl>
<p>Uses <code class="docutils literal"><span class="pre">canceldistance()</span></code> and <code class="docutils literal"><span class="pre">staircase()</span></code> for the tests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A,B,C</strong> (<em>{(n,n), (n,m), (pxn)} array_like</em>) &#8211; System matrices to be checked for minimality</li>
<li><strong>mu_tol</strong> (<em>float</em>) &#8211; The sensitivity threshold for the cancellation to be compared
with the first default output of canceldistance() function. The
default value is (default value is <span class="math">\(10^{-9}\)</span>)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A,B,C</strong> &#8211; System matrices that are identified as minimal with k states
instead of the original n where (k &lt;= n)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">{(k,k), (k,m), (pxk)} array_like</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldsvd">
<code class="descclassname">harold.harold.</code><code class="descname">haroldsvd</code><span class="sig-paren">(</span><em>D</em>, <em>also_rank=False</em>, <em>rank_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldsvd" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a wrapper/container function of both the SVD decomposition
and the rank computation. Since the regular rank computation is
implemented via SVD it doesn&#8217;t make too much sense to recompute
the SVD if we already have the rank information. Thus instead of
typing two commands back to back for both the SVD and rank, we
return both. To reduce the clutter, the rank information is supressed
by default.</p>
<p>numpy svd is a bit strange because it compresses and looses the
S matrix structure. From the manual, it is advised to use
u.dot(np.diag(s).dot(v)) for recovering the original matrix. But
that won&#8217;t work for rectangular matrices. Hence it recreates the
rectangular S matrix of U,S,V triplet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>D</strong> (<em>(m,n) array_like</em>) &#8211; Matrix to be decomposed</li>
<li><strong>also_rank</strong> (<em>bool, optional</em>) &#8211; Whether the rank of the matrix should also be reported or not.
The returned rank is computed via the definition taken from the
official numpy.linalg.matrix_rank and appended here.</li>
<li><strong>rank_tol</strong> (<em>{None,float} optional</em>) &#8211; The tolerance used for deciding the numerical rank. The default
is set to None and uses the default definition of matrix_rank()
from numpy.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>U,S,V</strong> (<em>{(m,m),(m,n),(n,n)} 2D numpy arrays</em>) &#8211; Decomposed-form matrices</li>
<li><strong>r</strong> (<em>integer</em>) &#8211; If the boolean &#8220;also_rank&#8221; is true, this variable is the numerical
rank of the matrix D</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldker">
<code class="descclassname">harold.harold.</code><code class="descname">haroldker</code><span class="sig-paren">(</span><em>N</em>, <em>side='right'</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldker" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is a straightforward basis computation for the right/left
nullspace for rank deficient or fat/tall matrices.</p>
<p>It simply returns the remaining columns of the right factor of the
singular value decomposition whenever applicable. Otherwise returns
a zero vector such that it has the same number of rows as the columns
of the argument, hence the dot product makes sense.</p>
<p>The basis columns have unity 2-norm except for the trivial zeros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>N</strong> (<em>(m,n) array_like</em>) &#8211; Matrix for which the nullspace basis to be computed</li>
<li><strong>side</strong> (<em>{'right','left'} string</em>) &#8211; The switch for the right or left nullspace computation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Nn</strong> &#8211; Basis for the nullspace. dim is the dimension of the nullspace. If
the nullspace is trivial then dim is 1 for consistent 2D array output</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(n,dim) array_like</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.ssconcat">
<code class="descclassname">harold.harold.</code><code class="descname">ssconcat</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.ssconcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a State() model as input and returns the matrix</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c|c}A&amp;B\\ \hline C&amp;D\end{array}\right]\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>G</strong> (<a class="reference internal" href="#harold.harold.State" title="harold.harold.State"><em>State()</em></a>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>M</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">2D Numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.ssslice">
<code class="descclassname">harold.harold.</code><code class="descname">ssslice</code><span class="sig-paren">(</span><em>H</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.ssslice" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a two dimensional array of size <span class="math">\(p\times m\)</span> and slices into
four parts such that</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c|c}A&amp;B\\C&amp;D\end{array}\right]\end{split}\]</div>
<p>For non-square slicing, see the method <code class="docutils literal"><span class="pre">matrixslice()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<em>2D Numpy array</em>) &#8211; </li>
<li><strong>n</strong> (<em>int</em>) &#8211; For a meaningful output, this number must staisfy <span class="math">\(n&lt;p,m\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>A</strong> (<em>2D Numpy array</em>) &#8211; The upper left <span class="math">\(n\times n\)</span> block of <span class="math">\(M\)</span></li>
<li><strong>B</strong> (<em>2D Numpy array</em>) &#8211; The upper right <span class="math">\(n\times (m-n)\)</span> block of <span class="math">\(M\)</span></li>
<li><strong>C</strong> (<em>2D Numpy array</em>) &#8211; The lower left <span class="math">\((p-n)\times n\)</span> block of <span class="math">\(M\)</span></li>
<li><strong>D</strong> (<em>2D Numpy array</em>) &#8211; The lower right <span class="math">\((p-n)\times (m-n)\)</span> block of <span class="math">\(M\)</span></li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.matrixslice">
<code class="descclassname">harold.harold.</code><code class="descname">matrixslice</code><span class="sig-paren">(</span><em>M</em>, <em>M11shape</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.matrixslice" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a two dimensional array of size <span class="math">\(p\times m\)</span> and slices into
four parts such that</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c|c}A&amp;B\\ \hline C&amp;D\end{array}\right]\end{split}\]</div>
<p>where the shape of <span class="math">\(A\)</span> is determined by <code class="docutils literal"><span class="pre">M11shape=(r,q)</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<em>2D Numpy array</em>) &#8211; </li>
<li><strong>M11shape</strong> (<em>tuple</em>) &#8211; An integer valued 2-tuple for the shape of <span class="math">\((1,1)\)</span> block element</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>A</strong> (<em>2D Numpy array</em>) &#8211; The upper left <span class="math">\(r\times q\)</span> block of <span class="math">\(M\)</span></li>
<li><strong>B</strong> (<em>2D Numpy array</em>) &#8211; The upper right <span class="math">\(r\times (m-q)\)</span> block of <span class="math">\(M\)</span></li>
<li><strong>C</strong> (<em>2D Numpy array</em>) &#8211; The lower left <span class="math">\((p-r)\times q\)</span> block of <span class="math">\(M\)</span></li>
<li><strong>D</strong> (<em>2D Numpy array</em>) &#8211; The lower right <span class="math">\((p-r)\times (m-q)\)</span> block of <span class="math">\(M\)</span></li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.eyecolumn">
<code class="descclassname">harold.harold.</code><code class="descname">eyecolumn</code><span class="sig-paren">(</span><em>width</em>, <em>nth=0</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.eyecolumn" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal"><span class="pre">nth</span></code> column of the identity matrix with shape
<code class="docutils literal"><span class="pre">(width,width)</span></code>. Slicing is permitted with the <code class="docutils literal"><span class="pre">nth</span></code> parameter.</p>
</dd></dl>

<dl class="function">
<dt id="harold.harold.system_norm">
<code class="descclassname">harold.harold.</code><code class="descname">system_norm</code><span class="sig-paren">(</span><em>state_or_transfer</em>, <em>p=inf</em>, <em>validate=False</em>, <em>verbose=False</em>, <em>max_iter_limit=100</em>, <em>hinf_tolerance=1e-10</em>, <em>eig_tolerance=1e-12</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.system_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the system p-norm. Currently, no balancing is done on the
system, however in the future, a scaling of some sort will be introduced.
Another short-coming is that while sounding general, only
<span class="math">\(\mathcal{H}_2\)</span> and <span class="math">\(\mathcal{H}_\infty\)</span>
norm are understood.</p>
<p>For <span class="math">\(\mathcal{H}_2\)</span> norm, the standard grammian definition via
controllability grammian, that can be found elsewhere is used.</p>
<p>Currently, the <span class="math">\(\mathcal{H}_\infty\)</span> norm is computed via
so-called Boyd-Balakhrishnan-Bruinsma-Steinbuch algorithm (See e.g. [2]).</p>
<p>However, (with kind and generous help of Melina Freitag) the algorithm
given in [1] is being implemented and depending on the speed benefit
might be replaced as the default.</p>
<p>[1] M.A. Freitag, A Spence, P. Van Dooren: Calculating the
<span class="math">\(\mathcal{H}_\infty\)</span>-norm using the implicit determinant method.
SIAM J. Matrix Anal. Appl., 35(2), 619-635, 2014</p>
<p>[2] N.A. Bruinsma, M. Steinbuch: Fast Computation of
<span class="math">\(\mathcal{H}_\infty\)</span>-norm of transfer function. System and Control
Letters, 14, 1990</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state_or_transfer</strong> (<em>{State,Transfer}</em>) &#8211; System for which the norm is computed</li>
<li><strong>p</strong> (<em>{int,Inf}</em>) &#8211; Whether the rank of the matrix should also be reported or not.
The returned rank is computed via the definition taken from the
official numpy.linalg.matrix_rank and appended here.</li>
<li><strong>validate</strong> (<em>boolean</em>) &#8211; If applicable and if the resulting norm is finite, the result is
validated via other means.</li>
<li><strong>verbose</strong> (<em>boolean</em>) &#8211; If True, the (some) internal progress is printed out.</li>
<li><strong>max_iter_limit</strong> (<em>int</em>) &#8211; Stops the iteration after max_iter_limit many times spinning the
loop. Very unlikely but might be required for pathological examples.</li>
<li><strong>hinf_tolerance</strong> (<em>float</em>) &#8211; Convergence check value such that when the progress is below this
tolerance the result is accepted as <em>converged</em>.</li>
<li><strong>eig_tolerance</strong> (<em>float</em>) &#8211; The algorithm relies on checking the eigenvalues of the Hamiltonian
being on the imaginary axis or not. This value is the threshold
such that the absolute real value of the eigenvalues smaller than
this value will be accepted as pure imaginary eigenvalues.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>n</strong> (<em>float</em>) &#8211; Computed norm. In NumPy, infinity is also float-type</li>
<li><strong>omega</strong> (<em>float</em>) &#8211; For Hinf norm, omega is the frequency where the maximum is attained
(technically this is a numerical approximation of the supremum).</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldlcm">
<code class="descclassname">harold.harold.</code><code class="descname">haroldlcm</code><span class="sig-paren">(</span><em>*args</em>, <em>*</em>, <em>compute_multipliers=True</em>, <em>cleanup_threshold=1e-09</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldlcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes n-many 1D numpy arrays and computes the numerical
least common multiple polynomial. The polynomials are
assumed to be in decreasing powers, e.g. s^2 + 5 should
be given as numpy.array([1,0,5])</p>
<p>Returns a numpy array holding the polynomial coefficients
of LCM and a list, of which entries are the polynomial
multipliers to arrive at the LCM of each input element.</p>
<p>For the multiplier computation, a variant of Karcanias, Mitrouli,
<em>System theoretic based characterisation and computation of the
least common multiple of a set of polynomials</em>, Lin Alg App, 381, 2004,
is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<em>1D Numpy array</em>) &#8211; </li>
<li><strong>compute_multipliers</strong> (<em>boolean</em>) &#8211; After the computation of the LCM, this switch decides whether the
multipliers of the given arguments should be computed or skipped.
A multiplier in this context is <code class="docutils literal"><span class="pre">[1,3]</span></code> for the argument <code class="docutils literal"><span class="pre">[1,2]</span></code>
if the LCM turns out to be <code class="docutils literal"><span class="pre">[1,5,6]</span></code>.</li>
<li><strong>cleanup_threshold</strong> (<em>float</em>) &#8211; The computed polynomials might contain some numerical noise and after
finishing everything this value is used to clean up the tiny entries.
Set this value to zero to turn off this behavior. The default value
is <span class="math">\(10^{-9}\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>lcmpoly</strong> (<em>1D Numpy array</em>) &#8211; Resulting polynomial coefficients for the LCM.</li>
<li><strong>mults</strong> (<em>List of 1D Numpy arrays</em>) &#8211; The multipliers for each given argument.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; a , b = haroldlcm(*map(np.array,([1,3,0,-4],[1,-4,-3,18],[1,-4,3],[1,-2,-8])))</span>
<span class="go">&gt;&gt;&gt;&gt; a</span>
<span class="go">    (array([   1.,   -7.,    3.,   59.,  -68., -132.,  144.])</span>

<span class="go">&gt;&gt;&gt;&gt; b</span>
<span class="go">    [array([  1., -10.,  33., -36.]),</span>
<span class="go">     array([  1.,  -3.,  -6.,   8.]),</span>
<span class="go">     array([  1.,  -3., -12.,  20.,  48.]),</span>
<span class="go">     array([  1.,  -5.,   1.,  21., -18.])]</span>

<span class="go">&gt;&gt;&gt;&gt; np.convolve([1,3,0,-4],b[0]) # or haroldpolymul() for poly mult</span>
<span class="go">    (array([   1.,   -7.,    3.,   59.,  -68., -132.,  144.]),</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldgcd">
<code class="descclassname">harold.harold.</code><code class="descname">haroldgcd</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldgcd" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes 1D numpy arrays and computes the numerical greatest common
divisor polynomial. The polynomials are assumed to be in decreasing
powers, e.g. <span class="math">\(s^2 + 5\)</span> should be given as <code class="docutils literal"><span class="pre">numpy.array([1,0,5])</span></code>.</p>
<p>Returns a numpy array holding the polynomial coefficients
of GCD. The GCD does not cancel scalars but returns only monic roots.
In other words, the GCD of polynomials <span class="math">\(2\)</span> and <span class="math">\(2s+4\)</span> is
still computed as <span class="math">\(1\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>1D Numpy arrays</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>gcdpoly</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">1D Numpy array</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; a = haroldgcd(*map(haroldpoly,([-1,-1,-2,-1j,1j],[-2,-3,-4,-5],[-2]*10)))</span>
<span class="go">&gt;&gt;&gt;&gt; a</span>
<span class="go">     array([ 1.,  2.])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It uses the LU factorization of the Sylvester matrix.
Use responsibly. It does not check any certificate of
success by any means (maybe it will in the future).
I have played around with ERES method but probably due
to my implementation, couldn&#8217;t get satisfactory results.
Hence I&#8217;ve switched to matrix-based methods. I am still
interested in better methods though, so please contact
me if you have a working implementation that improves
over this.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldcompanion">
<code class="descclassname">harold.harold.</code><code class="descname">haroldcompanion</code><span class="sig-paren">(</span><em>somearray</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldcompanion" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a 1D numpy array or list and returns the companion matrix
of the monic polynomial of somearray. Hence <code class="docutils literal"><span class="pre">[0.5,1,2]</span></code> will be first
converted to <code class="docutils literal"><span class="pre">[1,2,4]</span></code>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; haroldcompanion([2,4,6])</span>
<span class="go">    array([[ 0.,  1.],</span>
<span class="go">           [-3., -2.]])</span>

<span class="go">&gt;&gt;&gt;&gt; haroldcompanion([1,3])</span>
<span class="go">    array([[-3.]])</span>

<span class="go">&gt;&gt;&gt;&gt; haroldcompanion([1])</span>
<span class="go">    array([], dtype=float64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldtrimleftzeros">
<code class="descclassname">harold.harold.</code><code class="descname">haroldtrimleftzeros</code><span class="sig-paren">(</span><em>somearray</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldtrimleftzeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Trims the insignificant zeros in an array on the left hand side, e.g.,
<code class="docutils literal"><span class="pre">[0,0,2,3,1,0]</span></code> becomes <code class="docutils literal"><span class="pre">[2,3,1,0]</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>somearray</strong> (<em>1D Numpy array</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>anotherarray</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">1D Numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldpoly">
<code class="descclassname">harold.harold.</code><code class="descname">haroldpoly</code><span class="sig-paren">(</span><em>rootlist</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a 1D array-like numerical elements as roots and forms the polynomial</p>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldpolyadd">
<code class="descclassname">harold.harold.</code><code class="descname">haroldpolyadd</code><span class="sig-paren">(</span><em>*args</em>, <em>*</em>, <em>trimzeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldpolyadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to official polyadd from numpy but allows for
multiple args and doesn&#8217;t invert the order,</p>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldpolymul">
<code class="descclassname">harold.harold.</code><code class="descname">haroldpolymul</code><span class="sig-paren">(</span><em>*args</em>, <em>*</em>, <em>trimzeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldpolymul" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple wrapper around the scipy convolve function
for polynomial multiplication with multiple args.
The arguments are passed through the left zero
trimming function first.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;&gt; haroldpolymul([0,2,0],[0,0,0,1,3,3,1],[0,0.5,0.5])</span>
<span class="go">array([ 1.,  4.,  6.,  4.,  1.,  0.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="harold.harold.haroldpolydiv">
<code class="descclassname">harold.harold.</code><code class="descname">haroldpolydiv</code><span class="sig-paren">(</span><em>dividend</em>, <em>divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.haroldpolydiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Polynomial division wrapped around scipy deconvolve
function. Takes two arguments and divides the first
by the second.</p>
<p>Returns, two arguments: the factor and the remainder,
both passed through a left zeros trimming function.</p>
</dd></dl>

<dl class="function">
<dt id="harold.harold.frequency_response">
<code class="descclassname">harold.harold.</code><code class="descname">frequency_response</code><span class="sig-paren">(</span><em>G</em>, <em>custom_grid=None</em>, <em>high=None</em>, <em>low=None</em>, <em>samples=None</em>, <em>custom_logspace=None</em>, <em>input_freq_unit='Hz'</em>, <em>output_freq_unit='Hz'</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.frequency_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the frequency response matrix of a State() or Transfer()
object.</p>
<p>The State representations are always checked for minimality and,
if any, unobservable/uncontrollable modes are removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> (<em>State of Transfer</em>) &#8211; The realization for which the frequency response is computed</li>
<li><strong>custom_grid</strong> (<em>array_like</em>) &#8211; An array of sorted positive numbers denoting the frequencies</li>
<li><strong>high</strong> (<em>float</em>) &#8211; Power of 10 denoting the maximum frequency. If a discrete
realization is given this is overridden by the Nyquist frequency.</li>
<li><strong>low</strong> (<em>float</em>) &#8211; Power of 10 denoting the minimum frequency.</li>
<li><strong>samples</strong> (<em>int</em>) &#8211; Number of samples to be created between <cite>high</cite> and <cite>low</cite></li>
<li><strong>custom_logspace</strong> (<em>3-tuple</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>freq_resp_array</strong> (<em>Complex_valued numpy array</em>) &#8211; The frequency response of the system G</li>
<li><strong>w</strong> (<em>1D numpy array</em>) &#8211; Frequency grid that is used to evaluate the frequency response</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.pair_complex_numbers">
<code class="descclassname">harold.harold.</code><code class="descname">pair_complex_numbers</code><span class="sig-paren">(</span><em>somearray</em>, <em>tol=1e-09</em>, <em>realness_tol=1e-09</em>, <em>positives_first=False</em>, <em>reals_first=True</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.pair_complex_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array-like somearray, it first tests and clears out small
imaginary parts via <cite>numpy.real_if_close</cite>. Then pairs complex numbers
together as consecutive entries. A real array is returned as is.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>somearray</strong> (<em>array_like</em>) &#8211; Array like object needs to be paired</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; The sensitivity threshold for the real and complex parts to be
assumed as equal.</li>
<li><strong>realness_tol</strong> (<em>float</em>) &#8211; The sensitivity threshold for the complex parts to be assumed
as zero.</li>
<li><strong>positives_first</strong> (<em>bool</em>) &#8211; The boolean that defines whether the positive complex part
should come first for the conjugate pairs</li>
<li><strong>reals_first</strong> (<em>bool</em>) &#8211; The boolean that defines whether the real numbers are at the
beginning or the end of the resulting array.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>paired_array</strong> &#8211; The array that is paired</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">array_like</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.matrix_printer">
<code class="descclassname">harold.harold.</code><code class="descname">matrix_printer</code><span class="sig-paren">(</span><em>M</em>, <em>num_format='f'</em>, <em>var_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.matrix_printer" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a simple helper function for quickly carrying matrix data
to matlab. The array is assumed to be 1- or 2D. If the array is 3D
or more then use a slice in a for loop with explicit naming since
matlab does not have multidimensional entry syntax.</p>
<p>The <cite>var_name</cite> can be used in a loop for such purposes e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">matrix_printer</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">var_name</span> <span class="o">=</span> <span class="s1">&#39;A(:,:,2)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which will include the string <cite>A(:,:,2) =</cite> at the beginning of the
output string.</p>
<p>This function is inspired by
[Lee Archer&#8217;s gist](<a class="reference external" href="https://gist.github.com/lbn/836313e283f5d47d2e4e">https://gist.github.com/lbn/836313e283f5d47d2e4e</a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<em>Numpy array</em>) &#8211; The numpy array that is going to be pretty printed in matlab format.</li>
<li><strong>num_format</strong> (<em>str</em>) &#8211; String specifier (See Python documentation Section 6.1)</li>
<li><strong>var_name</strong> (<em>str</em>) &#8211; The name of the variable to be created in matlab.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mat</strong> &#8211; Resulting string</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.bodeplot">
<code class="descclassname">harold.harold.</code><code class="descname">bodeplot</code><span class="sig-paren">(</span><em>G</em>, <em>w=None</em>, <em>dont_draw=False</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.bodeplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the Bode plot of the system G. As the name implies, this only
creates a plot and for the data that is used <cite>frequency_response()</cite>
should be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> (<em>{State,Transfer}</em>) &#8211; The system for which the Bode plot will be drawn</li>
<li><strong>w</strong> (<em>array_like</em>) &#8211; Range of frequencies</li>
<li><strong>dont_draw</strong> (<em>bool</em>) &#8211; If True the figure handle is returned instead of directly drawing
to be used in elsewhere. The figure has no applied styles such as
title, grid etc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>plot</strong> &#8211; If <cite>dont_draw</cite> key is set to True then this returns the figure object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">matplotlib.figure.Figure</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="harold.harold.lyapunov_eq_solver">
<code class="descclassname">harold.harold.</code><code class="descname">lyapunov_eq_solver</code><span class="sig-paren">(</span><em>A</em>, <em>Y</em>, <em>E=None</em>, <em>form='c'</em><span class="sig-paren">)</span><a class="headerlink" href="#harold.harold.lyapunov_eq_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>This function solves the Lyapunov and the generalized Lyapunov
equations of the forms</p>
<ol class="arabic simple">
<li>X A + A^T X + Y = 0</li>
</ol>
<p>(1&#8217;)               A^T X A - X + Y = 0</p>
<p>and</p>
<ol class="arabic simple" start="2">
<li>E^T X A + A^T X E + Y = 0</li>
</ol>
<p>(2&#8217;)            A^T X A - E^T X E + Y = 0</p>
<p>for the unknown matrix <cite>X</cite> given square matrices A, E, and Y.
The numbered (primed) equations are the so-called continuous
(discrete) time forms. The <cite>form</cite> keyword selects between the
two.</p>
<p>For (1), (1&#8217;), the <cite>A</cite> matrix is brought to real Schur form
and for (2), (2&#8217;) QZ decomposition is used. Then all have a similar
forward substitution step. The method is a a modified implementation
of T. Penzl (1998).</p>
<p>If the argument <cite>E</cite> is not exactly a <cite>None</cite>-type then (2) is
assumed. Moreover, if (2) is assumed, the constant <cite>Y</cite> term
should be symmetric.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>, Y , E</strong> (<em>A</em>) &#8211; Data matrices for the equation. Y is a symmetric matrix.</li>
<li><strong>form</strong> (<em>'c' , 'continuous' , 'd' , 'discrete'</em>) &#8211; The string selector to define which form of Lyapunov equation is
going to be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X</strong> &#8211; Computed norm. In NumPy, infinity is also float-type</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">nxn numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-harold">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-harold" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Ilhan Polat.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.1a5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>